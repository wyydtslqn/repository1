# 第二周的学习内容+第三周内容

## 1 函数

```c
#include<stdio.h>
int main()
{
    printf("Hello,world!\n");
    return 0;
}
```

其实在我们学习的第一个程序“Hello,World!"中，我们已经接触到了函数，即main（）（主函数），接下来让我们更加深入的学习函数的知识。

### 1.1 函数的定义

何为函数？

类似于我们在数学当中的函数y=f（x），函数是一块代码，接受零个或多个参数，做一件事情，并返回零个或一个值。

函数的一般形式：

函数类型 函数名（形式参数表）//函数首部

{

函数的实现过程 //函数体

}

注：在调用一个函数时，函数名后面的小括号必不可少，就算这个函数不输入任何形参也不能删去，因为从某种意义上来讲，这个括号是在告诉电脑你在调用一个函数，如果不加括号，你也可能是在调用一个变量。

注：不可嵌套定义函数。

对于返回数值的函数，我们在函数体的结尾必须使用return语句返回一个参数值，如下面的求阶乘函数factorial（int n)：

```c
long factorial(int n)
{
    int i;
    long ret = 1;
    for (i = 1; i <= n; i++) {
        ret *= i;
    }
    return ret;
}
```

对于有返回值的函数，我们应尽量遵循单一入口和单一出口原则，单一入口我们能通过输入形参保证，而对于单一出口，我们应尽量只使用一个return语句返回参数值。

值得注意的是，函数返回值的类型和函数定义中类型是相同的。

而对于不返回值的函数，其函数类型为void，意为“无”。有一点需要区分的是，函数无返回值不代表ta没有用处，我们可以通过函数达到某种目的，如循环，判断等。

### 1.2 函数的调用

前面我了解了函数的定义，那么现在我们应该如何去调用一个函数呢？

函数调用的一般格式：

函数名（实际参数表）

不难发现，在函数定义里面我运用的是形式参数，而在函数调用中我们用到的是实际参数，关于二者的差异我们会在后续进行讨论。

函数调用的运行步骤是：当我们在主函数中运行到我们调用的函数时，我们的程序会先离开主函数，进入到被调用函数运行，直到被调用函数运行结束，再返回主函数。

我们的计算机在读取代码时，是按照从上到下的顺序逐行读取的，当我们的计算机读取到被调用函数时，如果前面没有此函数的定义，那么我们的计算机就不知道这个函数究竟是什么样子，程序就会出错。对于这个问题，其中一个解决办法就是把函数写在主函数之前，但这样做的问题在于先写被调用函数有一种喧宾夺主的意味，我们不能开门见山地将主函数呈现在读者面前，这样的写法被认为是不适合阅读的。而另一种解决方法就是函数声明。

函数声明的一般放在主函数之前，其一般格式为：

变量类型 函数名（形式参数表）；

也就是我们把函数头直接提前，值得注意的是函数声明中的形式参数的参数名不需要和后续函数声明中的参数名相同，甚至参数名都可以不出现，但是参数的类型一定要标出。

函数声明就好像是占了一个座，ta告诉计算机我们在这个程序中定义了一个函数，防止计算机被突然出现的陌生函数打一个措手不及（雾），同时在调用函数时帮我们跳转到被调用函数上。

如以下例子：

```c

#define _CRT_SECURE_NO_WARNINGS 
#include<stdio.h>
long factorial(int n);
int main()
{
    int  number = 0;

    scanf("%d", &number);
    printf("%d!=%ld", number, factorial(number));

    return 0;
}
long factorial(int n)
{
    int i;
    long ret = 1;
    for (i = 1; i <= n; i++) {
        ret *= i;
    }
    return ret;
}
```

在上述程序中，我们先在主函数前声明了一个函数，并在主函数后面给出了函数的定义，这样就能避免过于冗余。

### 1.3 参数传递

在调用函数时，如果函数有参数，调用时必须传递给它数量、类型正确的值。可以传递给函数的值是表达式的结果，这包括：

字面量  变量  函数的返回值  计算的结果

注：调用函数时给的值与参数的类型不匹配都c语言传统上最大的漏洞。编译器总是悄悄替你把类型转换好，但这可能并不是你所期望的。

```c
#define _CRT_SECURE_NO_WARNINGS 
#include<stdio.h>
void test(int);
int main()
{
    test(12.4);
    return 0;
}

void test(int n)
{
    int ret;
    ret = n;
    printf("%d\n", ret);

}
```

如在以上函数中，我们给test（）函数了一个12.4的值，最后的输出结果是12，并且这个问题编译器大概率甚至不会给出警告（起码Visual Stdio 2022不会）。

接下来让我们来讨论一下参数传递到底传递了什么？

让我们先来看以下代码：

```c
#define _CRT_SECURE_NO_WARNINGS 
#include<stdio.h>
//交换a和b的值（？）
void swap(int, int);
int main()
{
    int a = 5, b = 6;
    swap(a, b);
    printf("a=%d b=%d\n", a, b);
    return 0;
}

void swap(int x, int y)
{
    int t;
    t = x;
    y = x;
    y = t;
}
```

我们试图通过这个swap函数交换a和b的值，但是当我们运行时会发现a的值还是5，b的值还是6，这是为什么？

现在我们来解决我们最初的问题，参数传递实际传递的是参数的值，并不会将变量一同传递过去就算你将swap（）函数中的x和y替换为a和b结果也不会有任何改变。

当我们打开调试时，我们会发现当运行到main函数时，变量x、y、t不存在，而运行到swap函数时，变量a、b不存在。

每个函数都有自己的变量空间，参数也卫浴这个独立的空间中，和其他函数没有关系。

变量传递时只传值，这也是为什么前面说函数声明和函数定义时参数的变量名不一样的原因。

### 1.4 本地变量和全局变量

我们先给出两个概念——变量的生存期和作用域

生存期：变量在什么时候出现，又到什么时候消亡。

作用域：在（代码的）什么范围可以访问这个变量（这个变量可以起作用）。

对于本地变量（又称局部变量），这两个答案是统一的：大括号内——块

正如上文所说，对于1.3中的第二段代码，当程序运行到main函数时，变量x、y、t不存在，而运行到swap函数时，变量a、b不存在，这是因为这些变量都是本地变量，ta们只定义在大括号内，只作用和存在于大括号。

本地变量的规则：

·本地变量是定义在块内的，它可以是定义在函数的块内，也可以是定义在语句的块内，甚至可以随便   拉一大堆大括号来定义变量

·程序运行进入这个块前，其中的变量不存在，离开这个块，其中的变量就消失了

·块外面定义的变量在块里面仍然有效

·块里面定义了变量和外面同名的变量则会掩盖外面的

·不能在同一个块内定义同名的变量

·本地变量不会被默认初始化

·参数在进入函数时被初始化

当一些变量需要被多个函数共同使用时，参数传递虽然是一个办法，但必须通过调用函数实现，并且函数只能返回一个结果，这使得程序设计受到很大限制。为了解决多个函数间的变量共用，c语言允许定义全局变量。

定义在函数外而不属于任何函数的变量称为全局变量。全局变量的生存期和作用域是从定义开始到文件结束，它对作用范围内所有的函数都起作用。

全局变量的定义格式与本地变量完全一致，只是不定义在函数和语句内，它可以定义在程序的头部、中部和尾部，只要在函数外即可，不过一般情况下我们会将全局变量定义在程序的最前面，即第一个函数之前。

#### 附加——关于静态变量：

在静态存储区中，除了全局变量外，还有一种特殊的局部变量——静态局部变量。它的作用域是块内，但它的生存期却是从定义开始到文件结束，它不像局部变量那样随着函数结束便被系统回收，而是被系统一直储存，一经调用会被再次激活。

静态变量的定义格式：

static 类型名 变量表



## 2 数组

我们在之前可能写过求平均数的程序，它通过持续累加输入值来求得总值，进而求得平均值，这样并不需要我们储存输入的值。但倘若我们要输出所有大于平均数的值，我们就必须记录每一个值，这样我们就可以使用数组来达到这一目的。

何谓数组？

数组是一种容器（放东西的东西），特点是：

·其中所有的元素具有相同的数据类型

·一旦创建，不能改变大小

·数组中的元素是依次排列的

先看以下例子：

```c
#define _CRT_SECURE_NO_WARNINGS 
#include<stdio.h>
int main()
{
	int x;
	int cnt = 0;
	double sum = 0;
	int number[100] = { 0 };

	scanf("%d", &x);
	while (x != -1) {
		number[cnt] = x;
		cnt++;
		sum += x;
		scanf("%d", &x);
	}
	printf("%f\n", sum / cnt);
	int i;
	for (i = 0; i < cnt; i++) {
		if (number[i] > (sum / cnt))
			printf("%d\n", number[i]);
	}
	return 0;
}
```

在这个函数中，我们定义了一个数组number[100],用它来存储输入的数。

### 2.1 数组的定义

数组的一般格式为：
类型名 变量名[元素数量]；

如 int grades[100]；

double weight[20]；

注：元素数量必须是整数

### 2.2 数组的单元

数组的每个单元都是数组类型的一个变量

使用数组时放在[]中的数字叫做索引或下标，下标从0开始计数，即对于一个数组a[n]来说，该数组的单元包括a[0],a[1],……，a[n-1]。

#### 对于有效的下标范围：

调用数组时有效的下标范围是[0，数组的大小-1]，倘若下标范围超出了有效范围就会发生越界，会把数据写到其他变量所占据的存储单元中，甚至写入程序代码段，有可能造成严重后果。

编译器和运行环境都不会检查数组下标是否越界，无论是对数组单元做读还是写。

### 2.3 数组的大小

sizeof给出整个数组所占据的内容的大小，单位是字节，比如对于一个int类型的数组a[10],由于int类型的数据占据4个字节（也可能是2个），所以sizeof（a)的值为40（或20）

因此，我们要求数组的大小，可以写成如下形式：

```c
length=sizeof(a)/sizeof(a[0])
```

其中sizeof（a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数

这样的代码，一旦输入数组中初始的数据，不需要修改遍历的代码

### 2.4 数组的赋值

数组变量本身不能被赋值即下面的操作是不被允许的

```c
int a[]={2,3,45,6,7,1,12,34,6,34,123,}
int b[]=a;
```

要把一个数组的所有元素交给另一个数组，必须采用遍历

```c
for(i=0;i<length;i++){
    b[i]=a[i];
}
```

遍历数组时通常采用for循环，让循环变量i从0到<数组的长度，这样循环体内最大的i正好是数组最大的有效下标

常见错误是：

·循环结束的条件是<=数组长度or离开循环后，继续用i的值来做数组元素的下标

### 2.5 二维数组

二维数组一般形式如下：

类型 变量名[元素数量1]\[元素数量2];

如int a[3]\[5];

通常可以理解为一个3行5列的矩阵

二维数组的赋初值：

1. 分行赋初值

   一般形式为：

   类型名 变量名[行长度]\[列长度]={{初值表0}，……，{初值表k}，……}；

   把初值表k中的数据依次赋给第k行的元素，如：

   int a[3]\[3]={{1,2,3},{4,5,6},{7,8,9}};

   当然，我们也可以部分赋初值，如：

   int b[3]\[3]={{1,2,3},{},{4,5}};

   这样就只对b第0行的全部元素和第二行的前两个元素赋初值，其他元素的初值都是0。

2. 顺序赋初值

   一般形式：

   类型名 变量名[行长度]\[列长度]={初值表}；

   根据数组元素在内存中的存放顺序，把初值表的数据依次赋给元素。如：

   int a[3]\[3]={1,2,3,4,5,6,7,8,9};

   等价于

   int a[3]\[3]={{1,2,3},{4,5,6},{7,8,9}};

类似的，我们也可以来定义一个n维数组：

类型 变量名[元素数量1]\[元素数量2]……[元素数量n];

## 3 电脑硬件知识

### 3.1 硬件构成

计算机的主要组成：

主板、CPU、内存条、硬盘、显卡、电源

 主板：连接所有其他设备的设备，是其他设备的载体，主板主要是为CPU、内存、显卡、硬盘等提供平台，相当于人体的躯干，关联着各个器官。

CPU：中央处理单元（Central Processing Unit）的缩写，也叫处理器，是计算机的运算核心和控制核心。人靠大脑来思考，电脑靠CPU来运算、控制。让电脑的各个部件顺利工作，起协调作用和控制作用。

硬盘：存储资料和软件等数据的设备，有容量大，断电数据不丢失的特点。也被人们称为“数据仓库”。

内存：1、负责硬盘等硬件上的数据与CPU之间的数据交换处理；2、缓存系统中的临时数据；3、断电后数据丢失。

显卡：显示器想要显示画面，关键是显卡。简单来说，显卡就是负责在显示器上显示一切信息的设备。打个比方，它就像人类的眼睛，没有了它，电脑就无法驱动形成图像了。显卡性能越好，电脑的图形处理能力就越高，尤其是在玩游戏时更能体现这一点（很多游戏对显卡性能有要求）。对游戏玩家而言，最好选择独立显卡。不过，如果不玩大型游戏，CPU内置核心显卡也基本能满足要求。

电源：将电压220V的市电转换低等电压，然后送到主板的各个硬件。电脑运行需要电力，而电源就是为此供电的，可以说它在为电脑的一切提供动力。电源决定了电脑的稳定性。它和人体心脏的功能类似，都是提供动力的核心。

### 3.2 硬盘种类

硬盘的种类主要包括以下几种：

固态硬盘（SSD）

- 使用闪存颗粒作为存储介质。
- 提供快速的读写速度，通常没有机械部件，因此噪音和发热量较低。
- 适用于需要快速启动、加载和传输数据的设备，如笔记本电脑、游戏机和高端台式机。

机械硬盘（HDD）

- 使用磁性碟片来存储数据。
- 通常具有较大的存储容量和较低的价格。
- 适用于需要大量存储空间且预算有限的设备，如台式机、监控录像机和服务器。

混合硬盘（HHD）

- 结合了机械硬盘和固态硬盘的特点。
- 通常在机械硬盘的基础上增加一块小容量的固态硬盘作为缓存层，以提高读写速度。
- 适用于需要一定存储容量且希望获得较好性能的设备。

此外，硬盘的接口类型和性能也有所不同，常见的接口类型包括SATA、SAS、FC和SCSI等，它们各自有不同的传输速度和应用范围。

### 3.3 USB接口

| 区别           | USB2.0                                     | USB3.0                                         |
| -------------- | ------------------------------------------ | ---------------------------------------------- |
| **接口颜色**   | 黑色或者白色                               | 蓝色                                           |
| **针接口数量** | 4个针接口                                  | 9个针接口                                      |
| **传输速率**   | 传输速率为**30MB/S**，理论上限为**60MB/S** | 传输速率约为**320MB/S**，理论上限为**640MB/S** |
| **功耗**       | USB2.0供电能力为0.5A，功率为2.5W           | USB3.0的供电能力为1A也就是5W的功耗             |
| **工作模式**   | 半双工模式                                 | 全双工模式                                     |

**1，全双工模式**

当数据的发送和接收分流，分别由两根不同的传输线传送时，通信双方都能在同一时刻进行发送和接收操作，这样的传送方式就是全双工模式。

**2，半双工模式**

若使用同一根传输线既作接收又作发送，虽然数据可以在两个方向上传送，但通信双方不能同时收发数据,这样的传送方式就是半双工模式。

（打个比方：就像两条路，都是双行道，但是一条路没有信号灯，来往畅通无阻；另一条路上有红绿灯，走的时候需要等一等，不能一直通行。

没有信号灯的路=全双工；有红绿灯的，等一等的路=半双工）

当然，这个比方可能不太形象，但是能理解就好了，**反正就是USB3.0要比USB2.0传输速度快。**

### 3.4 VGA和HDMI

VGA（Video Graphics Array）和HDMI（High-Definition Multimedia Interface）都是视频接口标准，但它们在多个方面有所不同：

1. **信号类型**：

- VGA是模拟信号传输接口，主要用于传输模拟视频和音频。
- HDMI是数字信号传输接口，可以传输高清视频和音频。

1. **抗干扰性**：

- HDMI具有更好的抗干扰特性，在大尺寸、高分辨率、长距离连接方面优于VGA。

1. **传输速度**：

- HDMI的传输速度快，支持高清甚至4K视频传输。
- VGA传输速度较慢，不适合传输高清视频。

1. **带宽**：

- HDMI的带宽是数字信号带宽，而VGA是模拟信号带宽。
- 在传输相同分辨率视频的情况下，HDMI需要的带宽远高于VGA。

1. **接口设计**：

- HDMI接口包含视频信号、音频信号，并支持HDCP版权保护协议。
- VGA接口仅支持视频信号，不能传输音频信号，需要额外的音频线路连接。

1. **兼容性**：

- HDMI支持多种设备，包括电视、音响、游戏机、计算机等。
- VGA接口更常见于计算机显示器和一些旧设备。

总结来说，HDMI在画质、传输速度、音频视频一体化传输等方面都优于VGA，是现代高清视频传输的首选接口。然而，VGA仍然在一些场合下被使用，特别是与一些旧设备兼容时。

## 4 笔记本比较

暗影精灵10和拯救者Y7000P各有其特点和优势，选择哪个更好取决于你的具体需求和偏好。以下是两款电脑的一些比较：

### 暗影精灵10

- **处理器**：i9-14900HX，提供强大的性能。
- **显卡**：RTX4060，支持独显直连，性能释放可达180W。
- **屏幕**：240Hz刷新率，300尼特亮度，16.1英寸16:9屏幕。
- **内存**：标配32GB，无需额外升级。
- **键盘**：四区域RGB背光键盘。
- **价格**：i7-13650HX+RTX4060版本约6999元，i7-13650HX+RTX4070版本约8499元，性价比较高。

### 拯救者Y7000P**3**

- **处理器**：i7-14700HX和i7-14650HX，性能略低于i9-14900HX。
- **显卡**：RTX4060，整机性能释放180W，RTX4070，整机性能释放190W。
- **屏幕**：16英寸16:10的2.5K分辨率，165Hz刷新率，350尼特亮度。
- **内存**：标配16GB，支持双通道。
- **充电**：支持140W的PD充电。
- **散热**：采用内吹风方式，可能导致键盘区温度较高。
- **价格**：活动价格可能略低于暗影精灵10。

### 如何选择

- 如果你追求极致性能，且预算充足，可以选择新款R9000P，它拥有出色的屏幕和性能表现。
- 如果你注重性价比，且预算有限，可以选择暗影精灵10，尤其是i9-14900HX+RTX4060版本，性价比较高。
- 如果你需要更稳定的性能和均衡的配置，可以选择拯救者Y7000P，它以实用性和均衡性在市场中表现稳定。
- 如果你需要更好的屏幕和性能，但预算有限，可以考虑暗影精灵10的FHD屏幕版本，价格相对较低。

最终的选择应基于你的个人需求、预算以及对电脑性能、屏幕质量、散热性能等方面的重视程度。

## 5 阶乘求和

```c
#include<stdio.h>
int main()
{
	//阶乘求和
	int n, i, fact;
	long long sum = 0;
	fact = 1;
	scanf_s("%d", &n);
	for (i = 1; i <= n; i++) {
		fact *= i;
		sum += fact;
	}
	printf("阶乘的和为%lld\n", sum);
	return 0;

}
```

## 6 水仙花数

```c
#include<stdio.h>
#include<math.h>
int main()
{
	int i, b, a, sum;


	for (i = 100; i <= 999; i++) {
		b = i; a = 0, sum = 0;
		while (b > 0) {
			a = b % 10;
			b = b / 10;
			sum = sum + pow(a, 3);
		}
		if (sum == i)

			printf("%d\n", i);

	}
	return 0;
}


```

## 7 刷题

![](C:\Users\27730\AppData\Local\Temp\cf595fd1-2293-40de-93e8-79cbd5ffdd1e.png)